***************Check Services and Eventlogs

Get-help Get-Service

Get-Service -ComputerName "Servername" -Name "Service name"

Show-EventLog -ComputerName Server1

Get-EventLog -LogName System -Message "*restart*" -ComputerName Server1 |select * -First 1

cd
$t = Get-EventLog -LogName System -Source EventLog -Message "*shutdown*" | select * -First 1
Get-EventLog -LogName System -Before $t.TimeGenerated -Newest 5 -EntryType Error |
select TimeGenerated, Source, Message | Format-Table -Wrap


Useful Commands :

Check SQL Server Services status: Get-Service -ComputerName <Servername>| Where-Object {$_.displayname -like "SQ*"}

Check Event viewer:
Show-EventLog -ComputerName Server1
Get-EventLog -LogName System -Message "*service*" -ComputerName Server1 |select * -First 1

Get CPU and memory usage

Get-Counter '\Memory\Available MBytes'
Get-Counter '\Processor(_Total)\% Processor Time'

Get-Counter -ComputerName fcdb1546p  '\Processor(_Total)\% Processor Time' , '\Memory\Available MBytes'

Disk space using Powershell

Get-WmiObject Win32_logicaldisk -ComputerName fcdb640  | Format-Table SystemName, DeviceID, MediaType,  @{Name="Size(GB)";Expression={[decimal]("{0:N0}" -f($_.size/1gb))}},  @{Name="Free Space(GB)";Expression={[decimal]("{0:N0}" -f($_.freespace/1gb))}}, @{Name="Free (%)";Expression={"{0,6:P0}" -f(($_.freespace/1gb) / ($_.size/1gb))}}  -AutoSize

$srv=Get-Content 'C:\users\$rkurapa1\srv.txt'

SQL Service Account

PS SQLSERVER:\>$srv=Get-Content 'C:\users\$rkurapa1\srv.txt'
PS SQLSERVER:\> $res=@()
PS SQLSERVER:\> foreach ($s in $srv){write-host $s ;$res+=(Get-WmiObject win32_service -ComputerName $s| Where-Object {(
$_.name -like "MSSQL*") -and ($_.name -notlike "*FDL*") -and ($_.name -notlike "*ADHe*")})}
PS SQLSERVER:\> $res | Format-Table SystemName, name,startname,starmode,status | out-Gridview

Foreach($s in $srv) {$res+= (Get-WmiObject win32_service -computer WIN7NetBook, WIN7Laptop, WIN7Desktop | 
Where-Object {$_.name -match "^*SQL*"} | select SystemName, Name, StartName, PathName)


Disk Space
PS SQLSERVER:\> foreach ($s in $srv){ Get-WmiObject Win32_logicaldisk -ComputerName $s  | Format-Table SystemName, DeviceID, MediaType,  @{Name="Size(GB)";Expression={[decimal]("{0:N0}" -f($_.size/1gb))}},  @{Name="Free Space(GB)";Expression={[decimal]("{0:N0}" -f($_.freespace/1gb))}}, @{Name="Free (%)";Expression={"{0,6:P0}" -f(($_.freespace/1gb) / ($_.size/1gb))}}  -AutoSize}



$s=@()
$s=(Get-Counter -Listset *mssql*, *processor*,*memory*, *disk* -ComputerName <mysys> | Select-Object -ExpandProperty counter)
$s1=@()
$s1+=($s -like '*page life*') ,($s -like '*buffer cach*')

 $s1=$s -like '*\Processor(*)\% processor*'
 $s1=$s -like '*physicaldisk(*)\Current disk queue*'
 $s1=$s -like '*logicaldisk(*)\Current disk queue*'
 $s1+=$s -like '*\Processor(*)\% processor*'
 $s1+=$s -like '*physicaldisk(*)\Current disk queue*'
 $s1+=$s -like '*logicaldisk(*)\Current disk queue*'
 $s1+=$s -like '*Memory\available MBy*'
 $s1+=$s -like '*buffer cach*'
 $s1+=$s -like '*lock timeout*'
 $s1+=$s -like '*\Number of Deadlocks/sec*'
 $s1+=$s -like '*pending memory*'
 $s1+=$s -like '*user connections*'
 $s1+=$s -like '*Buffer Manager\Page life expectancy*'

Get-Counter -Counter $s1 -SampleInterval 5 -MaxSamples 5 | Export-Counter -Path 'C:\users\$rkurapa1\PerfExample.blg' -FileFormat BLG -Force

----Test if server is pingable 

Test-Connection -Quiet -ComputerName fcbllal9 -Count 1


---Connect to SQL using SMO and execute script.

$Filepath='E:\MyScriptsDirectory' # local directory to save build-scripts to
$DataSource='MyServer' # server name and instance
$Database='MyDatabase'# the database to copy from
# set "Option Explicit" to catch subtle errors
set-psdebug -strict
$ErrorActionPreference = "stop" # you can opt to stagger on, bleeding, if an error occurs
# Load SMO assembly, and if we're running SQL 2008 DLLs load the SMOExtended and SQLWMIManagement libraries
$ms='Microsoft.SqlServer'
$v = [System.Reflection.Assembly]::LoadWithPartialName( "$ms.SMO")
if ((($v.FullName.Split(','))[1].Split('='))[1].Split('.')[0] -ne '9') {
[System.Reflection.Assembly]::LoadWithPartialName("$ms.SMOExtended") | out-null
   }
$My="$ms.Management.Smo" #
$s = new-object ("$My.Server") $DataSource
if ($s.Version -eq  $null ){Throw "Can't find the instance $Datasource"}
$db= $s.Databases[$Database] 
if ($db.name -ne $Database){Throw "Can't find the database '$Database' in $Datasource"};
$transfer = new-object ("$My.Transfer") $db
$transfer.Options.ScriptBatchTerminator = $true # this only goes to the file
$transfer.Options.ToFileOnly = $true # this only goes to the file
$transfer.Options.Filename = "$($FilePath)\$($Database)_Build.sql"; 
$transfer.ScriptTransfer() 
"All done"

---Top 10 OS processes by CPU

Get-Process | Sort-Object CPU -desc | Select-Object -first 10 | Format-Table CPU,ProcessName -ComputerName <fcvdb459>

